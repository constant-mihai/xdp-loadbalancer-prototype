package bpf

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -verbose -tags linux -type services_by_index_value -cflags "-g -O2" xlbp ../../bpf/xlbp.c -- -I../../bpf/headers

// TODO: disabling optimizations will blow up the stack. By default this is limited to 512bytes.
// There's still a way around this by using the llvm -bpf-stack-size flag.
// I should make this configurable somehow.
// -g -O0 -mllvm -bpf-stack-size=4096

import (
	"encoding/binary"
	"fmt"
	"net"
	"sync"
	"sync/atomic"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"go.uber.org/zap"
)

const MaxInterfaces uint32 = 16

type Config struct {
	Interfaces map[string]string `mapstructure:"interfaces"`
}

type Dataplane struct {
	// Note: I struggled quite a bit to decide if I should use the xlbpObjects,
	// which is code generated by bpf2go, or if I should use the collection Object.
	// I still don't know which is the better choice. I'm writing down the diffs that
	// I know so far in case I ever double back to this decision:
	// - both xlbpObjects and a Collection have a Close()
	// - xlbpObjects.Close() propagates the error, collection doesn't.
	// - I can iterate through collection objects and can access them via their names from C.
	// The only benefit for using the collection is that I can dynamically iterate
	// through the map and rearrange the programs and maps into different structure if I want,
	// or, for example, to populate a BPF_MAP_TYPE_PROG_ARRAY.
	// The only downside for using the collection is that the error is not propagated
	// on close.
	collection        *ebpf.Collection
	interfaces        map[string]*net.Interface
	links             map[string]link.Link
	wg                sync.WaitGroup
	inShutdown        atomic.Bool
	logger            *zap.Logger
	interfaceCounters *interfaceCounters
}

type Service struct {
	Name string
	IP   net.IP
}

func LoadDataplane(config Config, logger *zap.Logger) (*Dataplane, error) {
	ifaces, err := getInterfacesByIPs(config.Interfaces)
	if err != nil {
		return nil, fmt.Errorf("error loading interfaces: %w", err)
	}

	spec, err := loadXlbp()
	if err != nil {
		return nil, fmt.Errorf("error getting spec: %w", err)
	}

	collection, err := ebpf.NewCollectionWithOptions(spec, ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel:     ebpf.LogLevelInstruction,
			LogSizeStart: 1024,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("error getting collection: %w", err)
	}

	// Note: my initial intention was to use multiple interfaces and load
	// different programs on each one. This can help separate logic and simplify
	// these programs (for example: an ingress program on a public facing interface
	// will possibly have a different implementation than a program on an internal facing
	// interface). However, if I would like to deploy the app in kubernets,
	// having multiple interfaces might be problematic.
	// Not sure if this will ever be needed, but the configuration file can dictate
	// which program gets loaded where.
	links := map[string]link.Link{}
	attachmentMappings := map[string]string{
		"external": "ingress",
		"internal": "ingress",
	}
	for ifcName, programName := range attachmentMappings {
		program, found := collection.Programs[programName]
		if !found {
			return nil, fmt.Errorf("program %s not found", programName)
		}

		ifc, found := ifaces[ifcName]
		if !found {
			return nil, fmt.Errorf("interface %s not found", ifcName)
		}

		logger.Info("Attaching program to interface",
			zap.String("program-name", programName),
			zap.Int("interface-index", ifc.Index),
		)

		link, err := link.AttachXDP(link.XDPOptions{
			Program:   program,
			Interface: ifc.Index,
		})
		if err != nil {
			return nil, fmt.Errorf("could not attach program %s to interface %d: %w",
				programName, ifc.Index, err)
		}

		links[programName] = link
	}

	for _, ifc := range ifaces {
		logger.Info("Inserting TX port for interface",
			zap.String("interface-type", "external"),
			zap.Int("interface-index", ifc.Index),
		)
		key := uint32(ifc.Index)
		value := uint32(ifc.Index)
		err := collection.Maps["xdp_tx_ports"].Update(key, value, ebpf.UpdateAny)
		if err != nil {
			return nil, fmt.Errorf("failed to populate XDP TX Ports: %w", err)
		}
	}

	interfaceCounters, err := newInterfaceCounters(logger, collection.Maps["interface_packet_counters"],
		collection.Maps["interface_byte_counters"], ifaces)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize counters")
	}

	// TODO: close counters
	return &Dataplane{
		interfaces:        ifaces,
		logger:            logger,
		collection:        collection,
		links:             links,
		interfaceCounters: interfaceCounters,
	}, nil
}

func (dp *Dataplane) Start() error {
	dp.wg.Add(1)
	go func() {
		dp.logger.Info("starting bpf metrics scraper")
		defer dp.wg.Done()
		ticker := time.NewTicker(5 * time.Second)
		defer ticker.Stop()
		for {
			if dp.inShutdown.Load() {
				return
			}

			<-ticker.C
			// read the interface counters
			dp.interfaceCounters.forEachInnerMap(dp.interfaceCounters.interfacePacketCounters, setPrometheusGauge, packetCounter)
			dp.interfaceCounters.forEachInnerMap(dp.interfaceCounters.interfaceByteCounters, setPrometheusGauge, byteCounter)
		}
	}()

	services := []Service{
		{"service-1", net.ParseIP("172.20.17.11")},
		{"service-2", net.ParseIP("172.20.17.12")},
		{"service-3", net.ParseIP("172.20.17.13")},
	}
	for i, service := range services {
		key := uint32(i)
		networkOrderIP := binary.BigEndian.Uint32(service.IP.To4())
		err := dp.collection.Maps["services_by_index"].Update(key, networkOrderIP, ebpf.UpdateAny)
		if err != nil {
			return fmt.Errorf("failed to populate services map: %w", err)
		}
	}

	return nil
}

func (dp *Dataplane) Close() error {
	dp.inShutdown.Store(true)
	dp.wg.Wait()

	for _, link := range dp.links {
		if link != nil {
			if err := link.Close(); err != nil {
				return fmt.Errorf("closing link: %w", err)
			}
		}
	}

	if dp.collection != nil {
		// the collection Close() function doesn't propagate the error.
		// unlink the xlbpObjects.Close() which does.
		dp.collection.Close()
	}

	dp.interfaceCounters.close()

	return nil
}

func getInterfacesByIPs(ipMap map[string]string) (map[string]*net.Interface, error) {
	result := make(map[string]*net.Interface)

	interfaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("failed to get interfaces: %w", err)
	}

	for configuredIfaceName, configuredIp := range ipMap {
		for _, iface := range interfaces {
			addrs, err := iface.Addrs()
			if err != nil {
				continue
			}

		AddrLoop:
			for _, addr := range addrs {
				ip, _, err := net.ParseCIDR(addr.String())
				if err != nil {
					ip = net.ParseIP(addr.String())
				}

				if ip != nil {
					if configuredIp == ip.String() {
						ifaceCopy := iface
						result[configuredIfaceName] = &ifaceCopy
						break AddrLoop
					}
				}
			}

		}
	}

	return result, nil
}
