package bpf

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -verbose -tags linux -type services_by_index_value -cflags "-g -O2" xlbp ../../bpf/xlbp.c -- -I../../bpf/headers

// TODO: disabling optimizations will blow up the stack. By default this is limited to 512bytes.
// There's still a way around this by using the llvm -bpf-stack-size flag.
// I should make this configurable somehow.
// -g -O0 -mllvm -bpf-stack-size=4096

import (
	"encoding/binary"
	"fmt"
	"net"
	"sync"
	"sync/atomic"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"go.uber.org/zap"
)

// TODO: I swear I did this in the past and know this was possible.
// Providing -type counter_index for the bpf2go command should generate a counter part enum in go.
// Instead I keep getting:
// Error: collect C types: type name counter_index: not found
// Until I figure out what's wrong this needs to be maintained by hand.
type CounterIndex uint32

const (
	IngressPacketsIdx CounterIndex = 0
	EgressPacketsIdx  CounterIndex = 1
	DropPacketsIdx    CounterIndex = 2
)

var (
	packetCounter = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: "xlbp",
			Name:      "external_interface_packets",
			Help:      "External interface",
		},
		[]string{"name", "flow", "direction"},
	)

	byteCounter = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: "xlbp",
			Name:      "external_interface_bytes",
			Help:      "External interface",
		},
		[]string{"name", "flow", "direction"},
	)
)

type Config struct {
	Interfaces map[string]string `mapstructure:"interfaces"`
}

type Dataplane struct {
	// Note: I struggled quite a bit to decide if I should use the xlbpObjects,
	// which is code generated by bpf2go, or if I should use the collection Object.
	// I still don't know which is the better choice. I'm writing down the diffs that
	// I know so far in case I ever double back to this decision:
	// - both xlbpObjects and a Collection have a Close()
	// - xlbpObjects.Close() propagates the error, collection doesn't.
	// - I can iterate through collection objects and can access them via their names from C.
	// The only benefit for using the collection is that I can dynamically iterate
	// through the map and rearrange the programs and maps into different structure if I want.
	// The only downside for using the collection is that the error is not propagated
	// on close.
	collection *ebpf.Collection
	interfaces map[string]*net.Interface
	links      map[string]link.Link
	wg         sync.WaitGroup
	inShutdown atomic.Bool
	logger     *zap.Logger
}

type Service struct {
	Name string
	IP   net.IP
}

func LoadDataplane(config Config, logger *zap.Logger) (*Dataplane, error) {
	ifaces, err := getInterfacesByIPs(config.Interfaces)
	if err != nil {
		return nil, fmt.Errorf("error loading interfaces: %w", err)
	}

	spec, err := loadXlbp()
	if err != nil {
		return nil, fmt.Errorf("error getting spec: %w", err)
	}

	collection, err := ebpf.NewCollectionWithOptions(spec, ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel: ebpf.LogLevelInstruction,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("error getting collection: %w", err)
	}

	links := map[string]link.Link{}
	attachmentMappings := map[string]string{
		"ingress_external": "external",
		"ingress_internal": "internal",
	}
	for programName, ifcName := range attachmentMappings {
		program, found := collection.Programs[programName]
		if !found {
			return nil, fmt.Errorf("program %s not found", programName)
		}

		ifc, found := ifaces[ifcName]
		if !found {
			return nil, fmt.Errorf("interface %s not found", ifcName)
		}

		logger.Info("Attaching program to interface",
			zap.String("program-name", programName),
			zap.Int("interface-index", ifc.Index),
		)

		link, err := link.AttachXDP(link.XDPOptions{
			Program:   program,
			Interface: ifc.Index,
		})
		if err != nil {
			return nil, fmt.Errorf("could not attach program %s to interface %d: %w",
				programName, ifc.Index, err)
		}

		links[programName] = link
	}

	return &Dataplane{
		interfaces: ifaces,
		logger:     logger,
		collection: collection,
		links:      links,
	}, nil
}

func (dp *Dataplane) Start() error {
	dp.wg.Add(1)
	go func() {
		dp.logger.Info("starting bpf metrics scraper")
		defer dp.wg.Done()
		ticker := time.NewTicker(5 * time.Second)
		defer ticker.Stop()
		for {
			if dp.inShutdown.Load() {
				return
			}
			<-ticker.C
			readCounters(dp.logger, dp.collection.Maps["packet_counters"], dp.collection.Maps["byte_counters"])
		}
	}()

	for _, ifc := range dp.interfaces {
		dp.logger.Info("Inserting TX port for interface",
			zap.String("interface-type", "external"),
			zap.Int("interface-index", ifc.Index),
		)
		key := uint32(ifc.Index)
		value := uint32(ifc.Index)
		err := dp.collection.Maps["xdp_tx_ports"].Update(key, value, ebpf.UpdateAny)
		if err != nil {
			return fmt.Errorf("failed to populate XDP TX Ports: %w", err)
		}
	}

	services := []Service{
		{"service-1", net.ParseIP("172.20.17.11")},
		{"service-2", net.ParseIP("172.20.17.12")},
		{"service-3", net.ParseIP("172.20.17.13")},
	}
	for i, service := range services {
		key := uint32(i)
		networkOrderIP := binary.BigEndian.Uint32(service.IP.To4())
		err := dp.collection.Maps["services_by_index"].Update(key, networkOrderIP, ebpf.UpdateAny)
		if err != nil {
			return fmt.Errorf("failed to populate services map: %w", err)
		}
	}

	return nil
}

func (dp *Dataplane) Close() error {
	dp.inShutdown.Store(true)
	dp.wg.Wait()

	for _, link := range dp.links {
		if link != nil {
			if err := link.Close(); err != nil {
				return fmt.Errorf("closing link: %w", err)
			}
		}
	}

	if dp.collection != nil {
		// the collection Close() function doesn't propagate the error.
		// unlink the xlbpObjects.Close() which does.
		dp.collection.Close()
	}

	return nil
}

func getInterfacesByIPs(ipMap map[string]string) (map[string]*net.Interface, error) {
	result := make(map[string]*net.Interface)

	interfaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("failed to get interfaces: %w", err)
	}

	// Create a reverse map: IP -> config key (e.g., "10.0.0.0" -> "external")
	ipToKey := make(map[string]string)
	for key, ip := range ipMap {
		ipToKey[ip] = key
	}

	for _, iface := range interfaces {
		addrs, err := iface.Addrs()
		if err != nil {
			continue
		}

		for _, addr := range addrs {
			ip, _, err := net.ParseCIDR(addr.String())
			if err != nil {
				ip = net.ParseIP(addr.String())
			}

			if ip != nil {
				if key, found := ipToKey[ip.String()]; found {
					// Create a copy of the interface to avoid pointer issues
					ifaceCopy := iface
					result[key] = &ifaceCopy
					// This IP was found, pop it from the map.
					delete(ipToKey, ip.String())
				}
			}
		}

		if len(ipToKey) == 0 {
			break
		}
	}

	if len(ipToKey) != 0 {
		for k, v := range ipToKey {
			return nil, fmt.Errorf("interface for %s:%s not found", v, k)
		}
	}

	return result, nil
}

func readCounters(logger *zap.Logger, counters *ebpf.Map, bytes *ebpf.Map) {
	key := uint32(IngressPacketsIdx)

	var values []uint64
	err := counters.Lookup(&key, &values)
	if err != nil {
		logger.Error("Failed to read packet counter", zap.Error(err))
		return
	}

	// Sum all per-CPU values
	var packetTotal uint64
	for _, value := range values {
		packetTotal += value
	}

	packetCounter.WithLabelValues("external", "ingress", "upstream").Set(float64(packetTotal))

	err = bytes.Lookup(&key, &values)
	if err != nil {
		logger.Error("Failed to read byte counter", zap.Error(err))
		return
	}

	// Sum all per-CPU values
	var bytesTotal uint64
	for _, value := range values {
		bytesTotal += value
	}

	byteCounter.WithLabelValues("external", "ingress", "upstream").Set(float64(bytesTotal))
}
